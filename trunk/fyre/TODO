CanvasElement.cs:
  * Add drawing.  This depends on the internal layout system being designed.
	This needs to be able to work both on gdk pixmaps and
	System.Drawing.Graphics surfaces (for clean-looking AA diagrams)
	so we can use the same code both for drawing on the canvas and
	creating a drag icon.  We might be able to just use System.Drawing
	for everything, but I don't know how well that works for GdkBitmap
	opacity masks.
  * This will also need to be able to handle mouseovers - we'll want a prelight
	on various parts of the element - main body, pads...

Element.cs:
  * Add some element information to the edit window. Probably at least name,
	icon and description.

ElementTooltip.cs:
  * It would be nice if the "description" field wrapped automatically without
	having to hardcode newlines, especially since we will probably want
	to show those descriptions elsewhere. I'm not sure how possible this
	is without height-for-width sizing, so the solution may just be
	word-wrapping ourselves using some pre-set character width.

NavigationImage.cs:
  * After moving around, the scrollbars look really weird until you mouse
	over them (for some reason). Dunno why.

Pipeline.cs:
  * This needs lots of design work before implementation can go forward.
  * We'll need some way to keep track of annotations (maybe composite).

PipelineDrawing.cs:
  * Make sure we trigger redraws when necessary
  * Add drawing code
  * We'll need a way of managing a selection - not sure if this should be in
	here or PipelineEditor

PluginManager.cs:
  * Make the warning dialog a little more sensible to people who aren't us.

Plugins all need element-specific implementation
  * Serialize()
  * DeSerialize()
  * Check()
  * Edit widgetry
  * any custom drawing
  * ...

Plugins to add:
  * Aggregator
  * Constant
  * Equation
  * Tee

General things:
  * Internal layout needs to be designed.
  * Global layout needs to be designed.  This will have hooks back into
	PipelineDrawing to manage layout extents, serialize itself,
	and generally be really slick.  In terms of code structure, it
	would be handy to have this as a completely separate library
	(Flibble#)
  * We need to figure out some way to serialize things for use in the
	clipboard.  We can probably just use the XML writer, and have it
	compute a new Guid on paste.
  * Pipeline checking. This should be done by getting a list of all the elements
	with the "Input" flag, propagating types through the pipeline until
	we've finished with all the "Output" flagged elements or we've
	exhausted all the possible connections.
  * Some convenience functions for the various Check() implementations would
	be very useful. In particular, we'll want things like IsInt, IsFloat,
	etc. It would probably also be nice to have some functions for
	extracting values and checking matrix rank/size.
  * We need to work out parallelization semantics. Right now i'm thinking
	that we'll parallelize on any operation from matrix->element type,
	and require that there be an aggregation flag on any element connected
	to the outside of a parallelizable.

Documentation:
  * Use cases
  * CRC cards - we should probably just do these on real paper. We don't need
	to do everything, but the major types would be good.
	-- David's got a preliminary set of these.  If you want to work on this,
	bug him.
  * Relationship diagrams:
	- Probably split up into a few different pieces to show specific
	"subsystems" rather than have one big mess. No reason we can't
	duplicate things within these diagrams.
  * Sequence diagrams:
	- Creating an element (+ other operations? show command pattern)
	- Loading plugins
	-- David's got one of these so far (NavigationWindow) on paper. If anyone
	wants to transcribe it into inkscape...

