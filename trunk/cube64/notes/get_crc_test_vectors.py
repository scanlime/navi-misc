#!/usr/bin/env python
#
# Using a microcontroller with the serial_bridge firmware installed,
# this sends several controller bus writes with different content.
# It reads back the controller-generated CRCs for each packet, storing
# the packet and CRC as test vectors for our reverse engineered CRC
# algorithm.
#
# The test vectors are stored as a pickled dictionary, mapping a 32-tuple
# of packet bytes to a CRC value.
#
# The test vectors include all zeros, all ones, a one in each possible
# bit position, pairs of ones, and several random packets. The packets with
# a one in each  possible bit position turn out to be very important
# for reproducing the CRC results.
#
# --Micah Dowty <micah@navi.cx>
#

import os, random, struct, cPickle

class SerialBridge:
    """Thin abstraction for using the serial_bridge device to calculate
       CRCs for packets using real Nintendo hardware. This assumes
       the serial port has already been set up for the right baud rate
       and such (38400 8-N-1)
       """
    def __init__(self, dev="/dev/ttyS0"):
        self.fd = os.open(dev, os.O_RDWR)

    def write(self, data, replyBytes=0):
        """Write the start-of-command identifier, the tramsmit length,
           receive length, then the data. Reads the proper number of reply
           bytes and returns them.
           """
        os.write(self.fd, struct.pack("BBB", 0x7E, len(data), replyBytes) + data)
        return os.read(self.fd, replyBytes)

    def refCRC(self, packet, address=0x8001):
        """Write the given packet to the controller bus at the given (encoded)
           address, returning the 8-bit CRC generated by the controller hardware.
           I've verified that the address has no effect on the returned CRC.
           """
        return ord(self.write(struct.pack(">BH", 3, address) +
                              ''.join([chr(i) for i in packet]), 1))

    def genVectors(self, seq):
        """Given a sequence of test packets, returns a dictionary mapping the packets to CRCs"""
        d = {}
        for packet in seq:
            crc = self.refCRC(packet)
            print "%s -> %02X" % (" ".join(["%02X" % b for b in packet]), crc)
            d[tuple(packet)] = crc
        return d


def packetGenerator():
    """A generator that yields all the packets we're going to test"""
    # Seed the PRNG with a constant so our output is predictable
    random.seed(12345)

    # All zeros
    packet = [0] * 32
    yield packet

    # All ones
    packet = [0xFF] * 32
    yield packet

    # Each bit set individually
    for byte in xrange(32):
        for bit in xrange(8):
            packet = [0] * 32
            packet[byte] = 1<<(7-bit)
            yield packet

    # Random pairs of bits set
    for i in xrange(500):
        packet = [0] * 32
        for j in xrange(2):
            byte = random.randint(0, 31)
            bit = random.randint(0, 7)
            packet[byte] |= 1<<(7-bit)
        yield packet

    # Completely random packets
    for i in xrange(500):
        yield [random.randint(0,255) for j in xrange(32)]


if __name__ == "__main__":
    filename = "crc_test_vectors.p"
    b = SerialBridge()
    vec = b.genVectors(packetGenerator())
    cPickle.dump(vec, open(filename, "wb"), -1)
    print "Saved to %s" % filename

### The End ###
