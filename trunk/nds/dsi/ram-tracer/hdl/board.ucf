#
# RAM Tracer revision 2, constraints and wiring information.
#
# This file contains both the FPGA constraints and some
# human-readable notes about other necessary hookups.
#
# This is designed for use with a bare Spartan 3E chip in the
# PQ208 package. I used the breakout board from Spark Fun electronics:
#
#  http://www.sparkfun.com/commerce/product_info.php?products_id=8458
#
# This design may be adaptable to other FPGAs, but please pay special
# attention to the I/O standards. All DSi memory bus connections must
# use 1.8v logic. In this design, those connections are all made on
# a separate bank (Bank 3) which takes its VccO from the DSi's 1.8v
# power rail.
# 
# -- Micah Dowty <micah@navi.cx>

########################################################
#
# USB interface: FTDI FT2232H Mini Module
#
# http://www.ftdichip.com/Products/EvaluationKits/FT2232H_MiniModule.htm
#

# This module is configured as USB Self-Powered, drawing its 5V
# power from the FPGA board.
#
#    CN2 pins 1,3,5 = V3V3
#    CN2 pins 11,21 + CN3 pins 12,22 = VIO
#    Connect V3V3 and VIO together.
#
#    Ground:    CN3-2
#    VCC (+5v): CN3-3

# All FT2232H connections are made on Bank 2 of the FPGA,
# configured with 3.3v I/O. Port B of the FT2232H is unused,
# since it is unavailable when using the high-speed synchronous
# FIFO. Port A is used in synchronous FIFO mode during normal
# operation, but we also use the FT2232H to configure the FPGA.
#
# During configuration:
#
#    D0-7:     Parallel configuration data from FT2232H to FPGA
#    CSI_B:    Chip select, must be low during configuration
#    RDWR_B:   Read/write, must be  low during configuration
#    CCLK:     Data clock (data latched on rising edge)
#    PROG_B:   Pulse low to reset FPGA. Must be high during config.
#    DONE:     Configuration successful?
#
# We'll use interface A in asynchronous bit-bang mode to actually
# clock out the configuration bitstream. The other relevant pins
# (CSI, RDWR, PROG, DONE) are connected to port B, also in bit-bang mode.
# These pins are connected via 1K series current-limiting resistors.
#
#    FT2232H Name     Pin#     FPGA Name   Pin#
#    ------------------------------------------
#
#    AD0              CN2-7    D0          P87   
#    AD1              CN2-10   D1          P83
#    AD2              CN2-9    D2          P82
#    AD3              CN2-12   D3          P78
#    AD4              CN2-14   D4          P77
#    AD5              CN2-13   D5          P76
#    AD6              CN2-16   D6          P75
#    AD7              CN2-15   D7          P74
#    AC0/RXF#         CN2-18   IO          P63
#    AC1/TXE#/WRSTB#  CN2-17   CCLK        P103
#    AC2/RD#          CN2-20   IO          P62
#    AC3/WR#          CN2-19   IO          P65
#    AC5/CLKOUT       CN2-24   M2/GCLK1    P81
#    BD0              CN3-26   CSI         P61
#    BD1              CN3-25   RDWR        P80
#    BD2              CN3-24*  DONE        P104
#    BD3              CN3-23*  PROG        P1
#
#  * = Series 330 ohm resistor
#
#  NOTE: All of the GCLK pins on bank 2 are shared with either
#        a data bit or with M2. We can't share with a data bit,
#        so we choose the lesser of two evils.. since M2 needs
#        to be 1 to select slave parallel configuration mode,
#        it's important that our CLKOUT pin is 1 or high-Z when
#        the FPGA starts up. This should be the case.
#







NET "ledseg_a<0>"  LOC = "E13"  ;
NET "ledseg_a<1>"  LOC = "F14"  ;
NET "ledseg_a<2>"  LOC = "G14"  ;
NET "ledseg_a<3>"  LOC = "d14"  ;

NET "ledseg_c<0>"  LOC = "E14"  ;
NET "ledseg_c<1>"  LOC = "G13"  ;
NET "ledseg_c<2>"  LOC = "N15"  ;
NET "ledseg_c<3>"  LOC = "P15"  ;
NET "ledseg_c<4>"  LOC = "R16"  ;
NET "ledseg_c<5>"  LOC = "F13"  ;
NET "ledseg_c<6>"  LOC = "N16"  ;
NET "ledseg_c<7>"  LOC = "P16"  ;

NET "led<0>"  LOC = "K12"  ;
NET "led<1>"  LOC = "P14"  ;
NET "led<2>"  LOC = "L12"  ;
NET "led<3>"  LOC = "N14"  ;
NET "led<4>"  LOC = "P13"  ;
NET "led<5>"  LOC = "N12"  ;
NET "led<6>"  LOC = "P12"  ;
NET "led<7>"  LOC = "P11"  ;

NET "reset"  LOC = "M13"  ;
#NET "button<0>"  LOC = "M13"  ;
#NET "button<1>"  LOC = "M14"  ;
#NET "button<2>"  LOC = "L13"  ;
#NET "button<3>"  LOC = "L14"  ;

# Normal onboard clock (50MHz)
#NET "mclk"  LOC = "T9" ;

# Flying lead for IFCLK from FX2 chip
NET "mclk"  LOC = "D9" ;

NET "mclk"  TNM_NET = mclk ;
TIMESPEC TS_mclk = PERIOD "mclk" 60 MHz HIGH 50%;

NET "switch<0>"  LOC = "F12"  ;
NET "switch<1>"  LOC = "G12"  ;
NET "switch<2>"  LOC = "H14"  ;
#NET "switch<3>"  LOC = "H13"  ;
#NET "switch<4>"  LOC = "J14"  ;
#NET "switch<5>"  LOC = "J13"  ;
#NET "switch<6>"  LOC = "K14"  ;
#NET "switch<7>"  LOC = "K13"  ;

NET "sram_oe" LOC = "K4";
NET "sram_we" LOC = "G3";

# Unused pins set to GND as shielding
NET "gndout<0>" LOC = "A12";
NET "gndout<1>" LOC = "A13";

#
# USB2 board on connector A1.
#
# The standard Digilent USB2 pinout is garbage, this
# one has been modified to bring out all of the pins
# necessary for using the FX2 in Slave FIFO mode.
#

NET "usb_d<0>" LOC = "M10";
NET "usb_d<1>" LOC = "F3";
NET "usb_d<2>" LOC = "G4";
NET "usb_d<3>" LOC = "E3";
NET "usb_d<4>" LOC = "F4";
NET "usb_d<5>" LOC = "G5";
NET "usb_d<6>" LOC = "E4";
NET "usb_d<7>" LOC = "H4";

#NET "usb_flaga" LOC = "H3";
NET "usb_flagb" LOC = "J3";
#NET "usb_flagc" LOC = "J4";
#NET "usb_rdy0" LOC = "K5";

#NET "usb_ifclk" LOC = "R5";
NET "usb_slwr" LOC = "N8";
NET "usb_slrd" LOC = "K5";
NET "usb_sloe" LOC = "T8";
NET "usb_pktend" LOC = "T5";
NET "usb_fifoadr<0>" LOC = "N7";
NET "usb_fifoadr<1>" LOC = "R6";


#
# DS RAM on A2 and B1
#
# XXX: These are really LVCMOS18 I/Os, but I don't have a good
#      way to put them in their own bank right now, so they're
#      stuck using 2.5v logic thresholds. Close enough?
#

NET "ram_a<0>" LOC = "M6";
NET "ram_a<1>" LOC = "B11";
NET "ram_a<2>" LOC = "G15";
NET "ram_a<3>" LOC = "E11";
NET "ram_a<4>" LOC = "H15";
NET "ram_a<5>" LOC = "C12";
NET "ram_a<6>" LOC = "E16";
NET "ram_a<7>" LOC = "B13";
NET "ram_a<8>" LOC = "D10";
NET "ram_a<9>" LOC = "A5";
NET "ram_a<10>" LOC = "B6";
NET "ram_a<11>" LOC = "C9";
NET "ram_a<12>" LOC = "B4";
NET "ram_a<13>" LOC = "D7";
NET "ram_a<14>" LOC = "F15";
NET "ram_a<15>" LOC = "K16";
NET "ram_a<16>" LOC = "E15";
NET "ram_a<17>" LOC = "B10";
NET "ram_a<18>" LOC = "B14";
NET "ram_a<19>" LOC = "D8";
NET "ram_a<20>" LOC = "B7";
NET "ram_a<21>" LOC = "H16";
NET "ram_a<22>" LOC = "G16";

NET "ram_d<0>" LOC = "R7";
NET "ram_d<1>" LOC = "J16";
NET "ram_d<2>" LOC = "D16";
NET "ram_d<3>" LOC = "C16";
NET "ram_d<4>" LOC = "B5";
NET "ram_d<5>" LOC = "C8";
NET "ram_d<6>" LOC = "A4";
NET "ram_d<7>" LOC = "A3";
NET "ram_d<8>" LOC = "N6";
NET "ram_d<9>" LOC = "B12";
NET "ram_d<10>" LOC = "D12";
NET "ram_d<11>" LOC = "A10";
NET "ram_d<12>" LOC = "B16";
NET "ram_d<13>" LOC = "A7";
NET "ram_d<14>" LOC = "C15";
NET "ram_d<15>" LOC = "D15";

NET "ram_clk" LOC = "C6";
NET "ram_oe" LOC = "L15";
NET "ram_we" LOC = "E7";
NET "ram_ce1" LOC = "K15";
NET "ram_ce2" LOC = "C7";
NET "ram_ub" LOC = "B8";
NET "ram_lb" LOC = "A8";
NET "ram_adv" LOC = "A9";

#NET "ram_clk_debug" LOC = "D6";
#NET "ram_buf_debug" LOC = "D5";

#
# DS clock output.
# This replaces the normal 16.756 MHz crystal.
#

NET "ds_osc_out" LOC = "T3";
