#
# Bootstrapper for the 'cookinject' exploit.
#
# Exploit code which takes control of Cooking Coach via a buffer overflow,
# downloads some payload code from the EEPROM emulator, calls the payload
# in order to inject code into the game, then "safely" resumes execution.
#
# This code is actually assembled into the name string in the save game,
# so it can't contain any NUL bytes. This means that some constants in our
# constant pool have to be obscured a bit, it means that often we have
# to have offsets in our ldr/str instructions when they wouldn't normally
# be necessary, and it makes the bl/blx instructions impractical to use.
#
# XXX: Only works with the US version for now. ("VCKE")
#
# Copyright (C) 2009 Micah Dowty <micah@navi.cx>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

        .thumb
        .global _start
_start:

        /*
         * Tiny nop slide, for paranoia...
         */
        mov	r1, #1
        mov	r1, #1
        mov	r1, #1
        mov	r1, #1


	/*****************************************************
	 * Load more code from SPI, from after the end of
	 * the save game memory (at 0x2000) and stick it in
	 * high RAM.
	 *
	 * This assumes you've either replaced the 8 KB
	 * EEPROM with a larger one, or that you're running
	 * an EEPROM emulator like this one. I'm using a
	 * homebrew FPGA design:
	 *
	 *   http://svn.navi.cx/misc/trunk/nds/spi-mem-emulator/
	 */

	/*
	 * Set NDS slot owner to ARM9
	 */
	ldr	r1, =(0x4000200 ^ 0xFFFFFFFF)
	ldr	r2, =0xFFFFFFFF
	eor	r1, r1, r2

	ldrh	r2, [r1, #0x4]    @ EXMEMCNT
	ldr	r3, =0xFFFFF7FF
	and	r2, r2, r3
	strh	r2, [r1, #0x4]

	/*
	 * Begin the SPI packet
	 *
	 * Uses r3 to store a pointer to 0x4000190,
	 * for reading/writing SPI registers.
	 *
	 * Uses r4 to store a busy flag mask (0x80)
	 */

	ldr	r3, =(0x4000190 ^ 0xFFFFFFFF)
	ldr	r1, =0xFFFFFFFF
	eor	r3, r3, r1
	mov	r4, #0x80         @ Busy flag

	ldr	r1, =0xffffa040   @ SPI enable, 4MHz, hold CS
	strh	r1, [r3, #0x10]   @ AUXSPICNT

	/*
	 * READ command, address 0x2000
	 */

	mov	r1, #0x03
	strh	r1, [r3, #0x12]   @ AUXSPIDATA
_b1:	ldrh	r2, [r3, #0x10]   @ AUXSPICNT
	tst	r2, r4            @ Busy?
	bne	_b1

	mov	r1, #0x20
	strh	r1, [r3, #0x12]   @ AUXSPIDATA
_b2:	ldrh	r2, [r3, #0x10]   @ AUXSPICNT
	tst	r2, r4            @ Busy?
	bne	_b2

	eor	r1, r1
	strh	r1, [r3, #0x12]   @ AUXSPIDATA
_b3:	ldrh	r2, [r3, #0x10]   @ AUXSPICNT
	tst	r2, r4            @ Busy?
	bne	_b3

	/*
	 * Load an arbitrary amount of code (64 KB)
	 * and store it at an arbitrary high RAM address (0x02c00000)
	 */

	ldr	r5, =(0x00010000 ^ 0xFFFFFFFF)
	ldr	r1, =0xFFFFFFFF
	eor	r5, r5, r1	  @ Length
	ldr	r6, =(0x02c00000 ^ 0xFFFFFFFF)
	eor	r6, r6, r1        @ Start address in r6
	mov	r7, r6            @ Save entry point for later
	add	r5, r5, r6	  @ Stop address in r5

readByte:
	eor	r1, r1            @ Dummy byte, for read
	strh	r1, [r3, #0x12]   @ AUXSPIDATA
_b4:	ldrh	r2, [r3, #0x10]   @ AUXSPICNT
	tst	r2, r4            @ Busy?
	bne	_b4
	ldrh	r1, [r3, #0x12]   @ The byte we just read

	strb	r1, [r6]	  @ Store to main memory
	add	r6, #1
	cmp	r5, r6
	bne	readByte

	/*
	 * Turn off SPI controller
	 */
	eor	r1, r1
	strh	r1, [r3, #0x10]   @ AUXSPICNT


	/*****************************************************
	 * Transfer control to the C startup code
	 * in start.s, which calls main().
	 */

	blx	r7                @ Set to 0x02c00000 above


	/*****************************************************
	 * Returning to the Game
	 */

        /*
         * We want to safely return to the game, but our last
         * couple of stack frames are toast because of the
         * exploit. We actually want to return from the topmost
         * function that's responsible for setting up the 'welcome'
         * screen (where we crashed). This function starts
         * at 0x2057FDC.
         *
         * This is a couple stack frames up from where we are.
         * The saved LR from that stack frame is 0x020f26b0.
         * We'll search up in our stack for this value, set
         * the SP, and return.
         *
         * Note that a copy of this code is also on the stack,
         * so we need to cloak our search key so we don't find
         * ourselves!
         */

        ldr	r1, =(0x020f26b0 ^ 0x55555555)
        ldr	r2, =0x55555555
        eor	r1, r1, r2
search:
        add	sp, sp, #4
        ldr	r3, [sp, #4]   @ Look for LR addr - 4
        cmp	r1, r3
        bne	search

        pop	{r4, pc}

        .pool
