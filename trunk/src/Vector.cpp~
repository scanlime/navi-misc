/*
 * Vector.cpp - Vector classes
 *
 * Copyright (C) 2002-2003 Micah Dowty and David Trowbridge
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 * 
 */

#include "Vector.h"
#include "Util.h"
#include <math.h>


/******************************************* Vector3 Class ***/

Vector3::Vector3() {
  vec[0] = vec[1] = vec[2] = 0;
}

Vector3::Vector3(float x, float y, float z) {
  vec[0] = x;
  vec[1] = y;
  vec[2] = z;
}

Vector3::Vector3(const float *v) {
  vec[0] = v[0];
  vec[1] = v[1];
  vec[2] = v[2];
}

Vector3::Vector3(const double *v) {
  vec[0] = v[0];
  vec[1] = v[1];
  vec[2] = v[2];
}

Vector3	&Vector3::operator = (const Vector3 &v) {
  vec[0] = v.vec[0];
  vec[1] = v.vec[1];
  vec[2] = v.vec[2];
  return *this;
}

Vector3	&Vector3::operator += (const Vector3 &v) {
  vec[0] = vec[0] + v.vec[0];
  vec[1] = vec[1] + v.vec[1];
  vec[2] = vec[2] + v.vec[2];
  return *this;
}

Vector3	&Vector3::operator -= (const Vector3 &v) {
  vec[0] = vec[0] - v.vec[0];
  vec[1] = vec[1] - v.vec[1];
  vec[2] = vec[2] - v.vec[2];
  return *this;
}

Vector3	&Vector3::operator %= (const Vector3 &v) {
  *this = (*this) % v;
  return *this;
}

Vector3	Vector3::operator % (const Vector3 &v) const {
  Vector3 u;
  u.vec[0] = vec[1]*v.vec[2] - vec[2]*v.vec[1];
  u.vec[1] = vec[2]*v.vec[0] - vec[0]*v.vec[2];
  u.vec[2] = vec[0]*v.vec[1] - vec[1]*v.vec[0];
  return u;
}

float Vector3::operator * (const Vector3 &v) const {
  return vec[0]*v.vec[0] + vec[1]*v.vec[1] + vec[2]*v.vec[2];
}

Vector3	&Vector3::operator *= (const float &f) {
  vec[0] *= f;
  vec[1] *= f;
  vec[2] *= f;
  return *this;
}

Vector3	&Vector3::operator /= (const float &f) {
  vec[0] /= f;
  vec[1] /= f;
  vec[2] /= f;
  return *this;
}

Vector3	Vector3::operator * (const float &f) const {
  Vector3 result;
  result.vec[0] = vec[0] * f;
  result.vec[1] = vec[1] * f;
  result.vec[2] = vec[2] * f;
  return result;
}

Vector3	Vector3::operator / (const float &f) const {
  Vector3 result;
  result.vec[0] = vec[0] / f;
  result.vec[1] = vec[1] / f;
  result.vec[2] = vec[2] / f;
  return result;
}

Vector3	Vector3::operator + (const Vector3 &v) const {
  Vector3 result;
  result.vec[0] = vec[0] + v.vec[0];
  result.vec[1] = vec[1] + v.vec[1];
  result.vec[2] = vec[2] + v.vec[2];
  return result;
}

Vector3	Vector3::operator - (const Vector3 &v) const {
  Vector3 result;
  result.vec[0] = vec[0] - v.vec[0];
  result.vec[1] = vec[1] - v.vec[1];
  result.vec[2] = vec[2] - v.vec[2];
  return result;
}

Vector3	&Vector3::normalize() {
  return ((*this) /= length());
}

Vector3	&Vector3::negate() {
  vec[0] = -vec[0];
  vec[1] = -vec[1];
  vec[2] = -vec[2];
  return *this;
}

Vector3	&Vector3::operator - () {
  return negate();
}

Vector3	&Vector3::zero() {
  vec[0] = vec[1] = vec[2] = 0;
  return *this;
}

void Vector3::set(float x, float y, float z) {
  vec[0] = x;
  vec[1] = y;
  vec[2] = z;
}

void Vector3::setv(Vector3 v) {
  *this = v;
}

Vector3 Vector3::perpendicular() const {
  static float squarezero = 1e-06 * 1e-06;
  Vector3 perp = (*this) % Vector3(1, 0, 0);
  if(perp.length2() < squarezero)
    perp = (*this) % Vector3(0, 1, 0);
  return perp;
}

float& Vector3::operator[] (unsigned int index) {
  return vec[index];
}

float Vector3::operator[] (unsigned int index) const {
  return vec[index];
}

float Vector3::get1(unsigned int index) const {
  return vec[index];
}

void Vector3::set1(unsigned int index, float value) {
  vec[index] = value;
}

Vector3::iterator Vector3::begin() {
  return vec;
}

const float *Vector3::get() const {
  return vec;
}

float Vector3::length() const {
  return sqrt(length2());
}

float Vector3::length2() const {
  return ((vec[0] * vec[0]) + (vec[1] * vec[1]) + (vec[2] * vec[2]));
}

bool Vector3::operator == (const Vector3 &v) const {
  return ((vec[0] == v.vec[0]) && (vec[1] == v.vec[1]) && (vec[2] == v.vec[2]));
}

bool Vector3::operator != (const Vector3 &v) const {
  return (vec[0] != v.vec[0]) || (vec[1] != v.vec[1]) || (vec[2] != v.vec[2]);
}

void Vector3::fillGL(GLfloat v[3]) const {
  v[0] = vec[0];
  v[1] = vec[1];
  v[2] = vec[2];
}

void Vector3::fromBuffer(Uint8 *v) {
  vec[0] = ((float*)v)[0];
  vec[1] = ((float*)v)[1];
  vec[2] = ((float*)v)[2];
}

void Vector3::toBuffer(Uint8 *v) const {
  ((float*)v)[0] = vec[0];
  ((float*)v)[1] = vec[1];
  ((float*)v)[2] = vec[2];
}

Vector3 &Vector3::rotate(float angle, float x, float y, float z) {
  float m[3][3];
  float c,s,t;

  /* Rotation matrix */
  angle *= -PI / 180;
  c = cos(angle);
  s = sin(angle);
  t = 1-c;
  m[0][0] = t*x*x + c;     m[1][0] = t*x*y - s*z;     m[2][0] = t*x*z + s*y;
  m[0][1] = t*x*y + s*z;   m[1][1] = t*y*y + c;       m[2][1] = t*y*z - s*x;
  m[0][2] = t*x*z - s*y;   m[1][2] = t*y*z + s*x;     m[2][2] = t*z*z + c;
  
  /* Multiply the vector by it */
  set( m[0][0] * vec[0]  + m[1][0] * vec[1]  + m[2][0] * vec[2],
       m[0][1] * vec[0]  + m[1][1] * vec[1]  + m[2][1] * vec[2],
       m[0][2] * vec[0]  + m[1][2] * vec[1]  + m[2][2] * vec[2] );
 
  return *this;
}


/******************************************* Vector2 Class ***/

Vector2::Vector2() {
  vec[0] = vec[1] = 0;
}

Vector2::Vector2(float x, float y) {
  vec[0] = x;
  vec[1] = y;
}

Vector2::Vector2(const float *v) {
  vec[0] = v[0];
  vec[1] = v[1];
}

Vector2::Vector2(const double *v) {
  vec[0] = v[0];
  vec[1] = v[1];
}

Vector2	&Vector2::operator = (const Vector2 &v) {
  vec[0] = v.vec[0];
  vec[1] = v.vec[1];
  return *this;
}

Vector2	&Vector2::operator += (const Vector2 &v) {
  vec[0] = vec[0] + v.vec[0];
  vec[1] = vec[1] + v.vec[1];
  return *this;
}

Vector2	&Vector2::operator -= (const Vector2 &v) {
  vec[0] = vec[0] - v.vec[0];
  vec[1] = vec[1] - v.vec[1];
  return *this;
}

float Vector2::operator * (const Vector2 &v) const {
  return vec[0]*v.vec[0] + vec[1]*v.vec[1];
}

Vector2	&Vector2::operator *= (const float &f) {
  vec[0] *= f;
  vec[1] *= f;
  return *this;
}

Vector2	&Vector2::operator /= (const float &f) {
  vec[0] /= f;
  vec[1] /= f;
  return *this;
}

Vector2	Vector2::operator * (const float &f) const {
  Vector2 result;
  result.vec[0] = vec[0] * f;
  result.vec[1] = vec[1] * f;
  return result;
}

Vector2	Vector2::operator / (const float &f) const {
  Vector2 result;
  result.vec[0] = vec[0] / f;
  result.vec[1] = vec[1] / f;
  return result;
}

Vector2	Vector2::operator + (const Vector2 &v) const {
  Vector2 result;
  result.vec[0] = vec[0] + v.vec[0];
  result.vec[1] = vec[1] + v.vec[1];
  return result;
}

Vector2	Vector2::operator - (const Vector2 &v) const {
  Vector2 result;
  result.vec[0] = vec[0] - v.vec[0];
  result.vec[1] = vec[1] - v.vec[1];
  return result;
}

Vector2	&Vector2::normalize() {
  return ((*this) /= length());
}

Vector2	&Vector2::negate() {
  vec[0] = -vec[0];
  vec[1] = -vec[1];
  return *this;
}

Vector2	&Vector2::operator - () {
  return negate();
}

Vector2	&Vector2::zero() {
  vec[0] = vec[1] = 0;
  return *this;
}

void Vector2::set(float x, float y) {
  vec[0] = x;
  vec[1] = y;
}

float& Vector2::operator[] (unsigned int index) {
  return vec[index];
}

float Vector2::operator[] (unsigned int index) const {
  return vec[index];
}

Vector2::iterator Vector2::begin() {
  return vec;
}

const float *Vector2::get() const {
  return vec;
}

float Vector2::length() const {
  return sqrt(length2());
}

float Vector2::length2() const {
  return (vec[0] * vec[0]) + (vec[1] * vec[1]);
}

bool Vector2::operator == (const Vector2 &v) const {
  return (vec[0] == v.vec[0]) && (vec[1] == v.vec[1]);
}

bool Vector2::operator != (const Vector2 &v) const {
  return (vec[0] != v.vec[0]) || (vec[1] != v.vec[1]);
}

void Vector2::fillGL(GLfloat v[2]) const {
  v[0] = vec[0];
  v[1] = vec[1];
}

void Vector2::fromBuffer(Uint8 *v) {
  vec[0] = ((float*)v)[0];
  vec[1] = ((float*)v)[1];
}

void Vector2::toBuffer(Uint8 *v) const {
  ((float*)v)[0] = vec[0];
  ((float*)v)[1] = vec[1];
}

float Vector2::get1(unsigned int index) const {
  return vec[index];
}

void Vector2::set1(unsigned int index, float value) {
  vec[index] = value;
}

void Vector2::setv(Vector2 v) {
  *this = v;
}
