/*
 * PerlinNoise.cpp - A model of SurfaceModifier that applies Perlin noise
 *                   along the surface's normal.
 *
 *  References:
 *     Perlin noise:
 *        http://freespace.virgin.net/hugo.elias/models/m_perlin.htm
 *        http://www.robo-murito.net/code/perlin-noise-math-faq.html
 *     Other terrain algorithms:
 *        http://www.vterrain.org/Elevation/artificial.html
 *        http://www.dgp.toronto.edu/~dh/screenshots.html
 *
 * Copyright (C) 2002-2003 Micah Dowty and David Trowbridge
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 * 
 */

#include "PerlinNoise.h"
#include <math.h>
#include <SDL/SDL.h>

void PerlinNoise::f(SurfacePoint &f) {
}

PerlinNoise::PerlinNoise(JetCOW *cow, Sint32 id, const char *type) : SurfaceModifier(cow,id,type) {
  /* Initialize the dictionary keys to reasonable values if this is a new object */
  if (id<0) {
    setAttr("Seed",SDL_GetTicks());
    setAttr("Persistence",0.25f);
    setAttr("Octaves",4);
    setAttr("Amplitude",1.0f);
    setAttr("Fundamental",1.0f);
  }
}

float PerlinNoise::noise(float x, float y) {
  return noise((int)x, (int)y);
}

float PerlinNoise::noise(int x, int y) {
  /* A simple deterministic pseudorandom number generator */
  int n;
  n = x + y * seed;
  n = (n<<13) ^ n;
  return ( 1.0 - ( (n * (n * n * 15731 + 789221) + 1376312589) & 0x7fffffff) / 1073741824.0); 
}

float PerlinNoise::smoothNoise(float x, float y) {
  /* This is an averaging function on top of the integer random noise generator */
  return ( noise(x-1, y-1)+noise(x+1, y-1)+noise(x-1, y+1)+noise(x+1, y+1) ) / 16  +
         ( noise(x-1, y)  +noise(x+1, y)  +noise(x, y-1)  +noise(x, y+1) )   /  8  +
           noise(x, y) / 4;
}

float PerlinNoise::interpolatedNoise(float x, float y) {
  /* After the noise has been blurred by the averaging, this
   * uses cosine interpolation to scale it up to any resolution.
   */

  int integer_X = int(x);
  float fractional_X = x - integer_X;
    
  int integer_Y = int(y);
  float fractional_Y = y - integer_Y;

  float v1 = smoothNoise(integer_X,     integer_Y);
  float v2 = smoothNoise(integer_X + 1, integer_Y);
  float v3 = smoothNoise(integer_X,     integer_Y + 1);
  float v4 = smoothNoise(integer_X + 1, integer_Y + 1);

  float i1 = interpolate(v1 , v2 , fractional_X);
  float i2 = interpolate(v3 , v4 , fractional_X);

  return interpolate(i1 , i2 , fractional_Y);
}

float PerlinNoise::perlinNoise(float x, float y) {
  float accumulator = 0;
  int i;
  float frequency = fundamental;
  float a = amplitude;

  /* The perlin noise function involves adding together smoothed random
   * noise at several octaves above a fundamental frequency.
   */
  for (i=0;i<octaves;i++) {
    accumulator += interpolatedNoise(x * frequency, y * frequency) * a;
    frequency *= 2;
    a *= persistence;
  }

  return accumulator;
}

float PerlinNoise::interpolate(float a, float b, float x) {
  /* Cosine interpolation */
  float ft = x * 3.1415927;
  float f = (1-cos(ft)) * 0.5;
  return a*(1-f) + b*f;
}

void PerlinNoise::saveCachedValues(void) {
  setAttrProtected("Seed", seed);
  setAttrProtected("Octaves", octaves);
  setAttrProtected("Persistence", persistence);
  setAttrProtected("Amplitude", amplitude);
  setAttrProtected("Fundamental", amplitude);
}

void PerlinNoise::loadCachedValues(void) {
  seed = getAttrIntProtected("Seed");
  octaves = getAttrIntProtected("Octaves");
  persistence = getAttrFloatProtected("Persistence");
  amplitude = getAttrFloatProtected("Amplitude");
  fundamental = getAttrFloatProtected("Fundamental");
}

