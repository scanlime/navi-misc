""" rcpod.device

A more pythonically-happy wrapper around the rcpod device.
Handles library initialization at import time, provides
a function for enumerating attached rcpod devices, and
a class encapsulating the device.
"""
#
# Remote Controlled PIC of Doom
# Copyright (C) 2003 Micah Dowty <micahjd@users.sourceforge.net>
#
#  This library is free software; you can redistribute it and/or
#  modify it under the terms of the GNU Lesser General Public
#  License as published by the Free Software Foundation; either
#  version 2.1 of the License, or (at your option) any later version.
#
#  This library is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Lesser General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#  License along with this library; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

from librcpod import *

# These are the symbols that will be pulled from this module
# into the 'pyrcpod' package.
__all__ = ['scanForDevices', 'devices']



class OpenedDevice:
    """Wraps an opened rcpod device, represented in librcpod
       by the rcpod_dev* opaque type.
       """
    def __init__(self, dev):
        self.dev = dev

    def reset(self):
        """Reset I/O-related registers to their power-on state.
           Automatically called in AvailableDevice.open() unless
           the 'reset' flag is set to False.
           """
        rcpod_Reset(self.dev)

    def poke(self, address, data):
        """Put the given 8-bit value into an address in the PIC's RAM.
           'address' can either be a numerical address or the name
           of a register (any RCPOD_REG_* or RCPOD_MEM_* constant).

           'data' can be either:
               - a character
               - a number between 0 and 255
               - a string
               - a list/tuple of values between 0 and 255

           If data is a list, tuple, or string, this function will poke
           multiple bytes starting at the given address.
           """
        # Convert strings and characters to lists and scalars
        if type(data) == type(''):
            if len(data) > 1:
                data = [ord(c) for c in data]
            else:
                data = ord(data)

        # If we have a scalar value, use rcpod_Poke. If we have
        # multiple bytes, use rcpod_PokeBuffer.
        if type(data) == type(()) or type(data) == type([]):
            # Create a C array with these values
            pass
        else:
            rcpod_Poke(self.dev, address, data)


class AvailableDevice:
    """A class representing an available but not opened rcpod device.
       Wraps the usb_device structure used by librcpod, and provides
       an open() method that creates an OpenDevice.
       """
    def __init__(self, usbdev):
        self.usbdev = usbdev

    def open(self, reset=True):
        """Open the device, and wrap it in an OpenedDevice class.
           By default the device is reset, though this can be overridden.
           """
        opened = OpenedDevice(rcpod_Open(self.usbdev))
        if reset:
            opened.reset()
        return opened


# A list of available rcpod devices (AvailableDevice instances)
# Generated by updateDevices
devices = []

def scanForDevices():
    """Scans for available rcpod devices, updates the 'devices' list"""
    global devices
    pyrcpod_findDevices()

    # Convert librcpod's linked list into a python list, wrapping
    # each device in an AvailableDevice instance
    llist = rcpod_GetDevices()
    devices = []
    while llist:
        devices.append(AvailableDevice(llist))
        llist = pyrcpod_nextDevice(llist)

# Initialize librcpod and build an initial list of attached devices
pyrcpod_init()
scanForDevices()

### The End ###
